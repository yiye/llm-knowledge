# Product Agent Workbench: The "Cursor" for Business Knowledge
> **产品代号**: Workbench / Knowledge OS
> **核心定位**: 一个以「编辑」为核心，将「碎片想法 (Sticker)」与「体系文档」转化为「业务动作」的 Agentic 工作台。
> **一句话愿景**: 让文档不仅是被阅读的静态文字，而是驱动业务流转的可执行代码 (Executable Documentation)。

---

## 0. 灵感之源 (Origin Story)

这个产品的诞生源于四个真实的瞬间：

1.  **被埋没的智慧 (The Buried Wisdom)**: 翻看过去的文档时，发现里面充满了极具前瞻性的观点和知识点。但因为它们只是静态的文字，随着时间流逝被埋葬在文件夹深处，从未被真正“执行”过。这让我意识到：**死掉的知识没有力量，沉淀不应是终点。**
2.  **表单 vs 文档 (Form vs Doc)**: 在做自动化配置系统时，虽然我们提供了结构完美的表单，但 PD 们依然更喜欢写文档。因为文档灵活、自由，能承载复杂的逻辑，而表单是僵硬的。**人脑喜欢自由表达，不喜欢填空。**
3.  **对话的流逝 (The Fleeting Chat)**: 大家现在习惯和 ChatGPT 对话，但 Chat 是流动的、易逝的。AI 生成了很有价值的内容，但往往止步于一次性的问答，没有沉淀为固定的、可复用的**知识资产**。
4.  **Cursor 的启示 (The IDE Epiphany)**: Cursor 最让我们着迷的不仅仅是补全代码，而是它打通了**从知识到现实的闭环**。
    *   **Agent (Composer)**: 它能主动搜索整个 Codebase（连接知识）。
    *   **Terminal (Execution)**: 它能直接执行命令、运行测试（连接现实）。
    *   **如果 IDE 能让代码变成运行的程序，那么 Workbench 就能让文档变成运行的业务。** 这就是我们想做的。

---

## 1. 第一性原理 (The First Principle)

**知识是一切的起点。**

在未来的企业中，人类不应再充当系统的"人肉接口"或"搬运工"，人的核心职责将回归于：
1.  **创造知识 (Create)**: 产生创新的点子、策略和技术方案。
2.  **整理知识 (Organize)**: 将碎片化的灵感 (Stickers) 沉淀为确定性的体系 (Docs)。
3.  **链接现实 (Link)**: 也就是本产品的核心——通过 Agent 将静态的知识**投射**到现实世界，直接产出价值。

**在这个范式下，文档即源码，企业即运行时。**

---

## 2. 核心洞察 (The Core Insight)

### 2.1 痛点：死掉的知识
在传统工作流中（Notion/Google Docs），文档是业务的**终点**或**墓地**。
*   写完 PRD，需要人脑理解，再手动去配置后台、建 Jira、写代码。
*   写完会议纪要，需要人工去把 Todo 搬运到任务管理软件。
*   **文档是“死”的，Cursor 里的代码是“活”的**（因为有 LSP、有编译器、有 Terminal）。

### 2.2 机会：文档即代码 (Docs as Code/Context)
借用 Cursor 的哲学：**如果 IDE 能读懂代码并执行重构，那么 Workbench 也能读懂文档并执行业务。**

$$
\text{Value} = \text{Input (Knowledge)} \xrightarrow{\text{Process (Agent)}} \text{Output (Reality)}
$$

*   **Input**: PRD 文档 / 随手记的 Sticker —— **这是人的工作（定义知识）**。
*   **Process**: Agent 理解上下文 + Tool Use —— **这是机器的工作（理解意图）**。
*   **Output**: 内部系统配置 / 数据库 SQL / 自动化脚本 / Jira Ticket —— **这是系统的反馈（产出价值）**。

我们不仅需要一个更好的写作工具，更需要一个**业务编排器**。
*   **回归编辑**：通过极致的编辑体验（Context-Aware, Diff View），把人脑中模糊的意图沉淀为**确定性的知识**。
*   **文档即接口**：文档写定之时，即是业务执行之始。通过挂载 **Skills**，Agent 读取文档并操作现实世界。

---

## 3. 核心架构：三层知识流转 (The Knowledge Flow)

### Layer 1: The Context Factory (知识沉淀层)
这是用户停留 90% 时间的地方，负责将杂乱的信息结构化。
*   **Structured Docs (体系化知识)**: PRD、技术方案、团队规划。这是 Agent 的 "Long-term Memory"。
*   **Stickers (碎片化知识)**: 
    *   类似桌面便签，记录 "临时 Todo"、"灵光一现"、"口头需求"。
    *   **关键特性**: Sticker 不是废纸，它是 **Context Seed (上下文种子)**。Agent 可以一键将 Sticker "织入" (Weave) 到正式文档中，或者转化为一个具体的 Task。
*   **Intelligent Editing**: 类似 Cursor 的补全与重构，但在文档层面工作。

### Layer 2: The Agent Brain & Skills (意图理解与能力层)
*   **Active Listening (意图识别)**: 编辑器不再被动等待，而是实时理解上下文。
    *   *例子*: Agent 监测到你修改了 "活动奖励字段"，自动联想到这需要同步给 "运营配置系统"。
*   **Skill System (能力挂载)**: 类似于插件系统，按需为编辑器安装“手脚”。
    *   🛠️ **Jira/Linear Skill**: 文本 -> 工单。
    *   ⚙️ **Config Skill**: 描述 -> JSON/YAML 配置。
    *   📊 **Data Skill**: 问题 -> SQL 查询。

### Layer 3: The Execution Bridge (业务执行层)
*   **Human-in-the-loop**: Agent 识别出意图后，生成 **"Action Preview" (执行预览)**。
    *   *用户交互*: 文档侧边栏弹出 "检测到 3 个配置变更" -> 点击预览 Diff -> 确认无误 -> 执行。
*   **Ops Automation**: 真正调用 API，修改数据库，发送通知。

---

## 3. The Rise of Agent Skills (为什么是 Skills?)

> **Industry Trend**: 2025 被称为 "Year of the AI Agent"。行业正在从单纯的 Chatbot 向 Agentic Workflow 转变。Semantic Kernel 称之为 Plugins，LangChain 称之为 Tools，我们称之为 **Skills**。

**Agent Skills** 是链接「静态文档」与「动态世界」的桥梁。它们不仅仅是 API Wrapper，更是包含业务逻辑的**能力胶囊**。

*   **封装性**: 一个 `VoucherSkill` 包含了如何创建券、如何校验互斥、如何下线的全部逻辑。
*   **可插拔**: 像 VS Code 插件一样，不同的团队可以开发不同的 Skill（如 `Feishu Skill`, `Salesforce Skill`）。
*   **语义化**: Skill 通过自然语言描述（Description）告诉 Agent 它能做什么，Agent 根据文档上下文自动选择最合适的 Skill。

### 3.1 Self-Learning Skills: 从工具到智能体 (2026 Trend) 🔥

> **技术演进**: 2023-2024 的 Agent 工具是静态的（Fixed Schema），2025-2026 的趋势是让 Skills 具备**自我进化能力** (Self-Improving Tools)，通过收集执行反馈和业务知识不断优化。

传统的 Skills 是"死"的工具：你定义了什么，它就只能做什么。但在 Workbench 中，**Skills 会从每一次使用中学习**，逐步成为领域专家。

#### 3.1.1 学习机制 (Learning Mechanisms)

**📊 执行反馈收集 (Execution Feedback Loop)**
```
用户执行 → Agent 调用 Skill → 获得结果 → 用户反馈（成功/失败/修正）
                                    ↓
                        反馈写入 Skill Memory (向量数据库)
```

*   **成功案例沉淀**: 
    *   用户写 "满100减10券"，`VoucherSkill` 成功生成配置并执行。
    *   这个 **<文本描述 -> 配置结构>** 的映射被记录为"最佳实践"。
    *   下次遇到类似描述时，Skill 直接复用这个 Pattern。

*   **失败案例学习**: 
    *   用户写 "满50减100券"，系统报错 "优惠金额不能大于门槛"。
    *   这个错误被标注为 **Anti-Pattern**，同时提取规则："if value > threshold → reject"。
    *   未来 Agent 会在执行前主动提醒用户。

**🧠 业务规则提取 (Business Rule Mining)**
*   当用户多次修改某个配置字段时，Skill 会自动识别**隐含的业务规则**。
    *   *例子*: 发现 "新人券" 总是和 "满减券" 互斥配置，自动建议："检测到新人券配置，是否需要设置与满减券的互斥规则？"
*   **规则来源**: 不是写死在代码里，而是从真实的业务文档和操作日志中**挖掘**出来。

**🔄 Schema 自动演进 (Schema Evolution)**
*   Skills 的输入 Schema 不是固定的，而是**动态扩展**的。
    *   初始版本的 `VoucherSkill` 可能只支持 "满减券"。
    *   当用户频繁提到 "折扣券" 时，Skill 会建议："检测到新的券类型 '折扣券'，是否需要扩展 Schema？"
    *   用户确认后，Schema 自动增加 `discount_rate` 字段。

#### 3.1.2 知识共享与协作 (Skill Collaboration)

**Skills 不是孤岛，而是会互相学习和协作**：

*   **跨 Skill 知识迁移**: 
    *   `VoucherSkill` 学到的 "互斥规则" 模式，可以迁移到 `ActivitySkill` 中（活动之间也需要互斥）。
    *   通过 **Skill Knowledge Graph**，不同 Skills 共享通用的业务逻辑。

*   **团队集体智慧**: 
    *   当 PD-A 成功配置了一个复杂的券组合规则时，这个知识会沉淀到团队的 **Skill Library** 中。
    *   PD-B 遇到类似需求时，Skill 会主动建议："检测到类似的配置模式，是否参考 PD-A 在 PRD-2023 中的方案？"

#### 3.1.3 用户教学：从需求到 Skill 生成 (Teaching Agent to Build Skills) 🌟

> **核心理念**: Agent 不应该只会使用预定义的 Skills，更应该能**从用户的示教中学习**，自主构建新的 Skills。这是从"工具使用者"到"工具创造者"的飞跃。

**传统模式的困境**：
*   开发者手写 Skill 代码 → 提交 → 部署 → 用户使用。
*   新业务需求出现时，用户只能等待开发者开发新 Skill。
*   **瓶颈**：Skill 的创建速度 < 业务需求的变化速度。

**Workbench 的革新**：**用户通过自然语言 + 演示，教 Agent 构建新 Skill**。

---

##### 3.1.3.1 教学方式：三种路径

**🎯 路径 1：对话式教学 (Conversational Teaching)**

用户通过自然语言描述需求，Agent 提问澄清，最终生成 Skill。

<details>
<summary>📖 示例：教 Agent 创建 "发送飞书通知" Skill</summary>

```
【用户】我想创建一个 Skill，能在文档中提到 @某人 时，自动发飞书通知

【Agent】好的！我需要了解几个信息：
1. 飞书通知的内容应该包含什么？（文档标题？具体段落？）
2. 是立即发送，还是需要用户确认后发送？
3. 需要支持群组通知吗？

【用户】
1. 内容包含：文档标题 + @提到的完整句子
2. 需要用户确认后发送（预览机制）
3. 暂时只支持单人通知

【Agent】明白了！我还需要：
- 飞书 Webhook URL 或 Bot Token（从哪里获取？）
- 当文档中有多个 @某人 时，是合并为一条通知还是分别发送？

【用户】
- 从系统环境变量 FEISHU_BOT_TOKEN 读取
- 分别发送

【Agent】✅ 已生成 `FeishuMentionSkill`！
Schema:
{
  "action": "send_mention",
  "mentioned_user": "张三",
  "doc_title": "Q1 产品规划",
  "context": "张三，请 review 这个方案"
}

API 调用逻辑已生成，是否需要测试？
```
</details>

**🎬 路径 2：示范式教学 (Learning by Demonstration)**

用户实际操作一遍，Agent 观察并提取模式，自动生成 Skill。

<details>
<summary>📖 示例：通过示范教 Agent 配置数据库表</summary>

```
【场景】用户需要在数据库中创建新表的 Skill

【第 1 步】用户在文档中写：
"""
新增表：user_growth_task
字段：task_id (主键), user_id (索引), reward_points, status
"""

【第 2 步】用户手动打开数据库管理工具，执行 SQL：
CREATE TABLE user_growth_task (
  task_id BIGINT PRIMARY KEY,
  user_id BIGINT,
  reward_points INT,
  status VARCHAR(20),
  INDEX idx_user_id (user_id)
);

【第 3 步】Agent 监测到：
- 文档描述 <-> SQL 语句 的映射关系
- 字段类型推断规则（id → BIGINT, points → INT）
- 索引规则（标注"索引"的字段自动创建索引）

【Agent 提示】
"我观察到你刚才手动执行了建表操作。我可以学习这个模式，
下次遇到类似的表结构描述时，自动生成 SQL。是否创建 `DatabaseSchemaSkill`？"

【用户】确认

【结果】
以后用户只需在文档中写表结构描述，Agent 自动生成 SQL 并提供预览。
```
</details>

**📚 路径 3：文档归纳式学习 (Pattern Extraction from Docs)**

Agent 分析用户的历史文档，主动发现重复模式，建议创建 Skill。

<details>
<summary>📖 示例：从重复操作中学习</summary>

```
【Agent 发现】
你在过去 3 个月的文档中，有 12 次提到类似的操作：
- "配置 XX 活动的开始时间、结束时间、参与条件"
- "设置 YY 活动的奖励规则、用户白名单"

这些操作都遵循相似的结构：
{
  activity_name, start_time, end_time, 
  participation_rules, reward_config, whitelist
}

【Agent 建议】
"我可以为你创建一个 `ActivityConfigSkill`，
下次你只需在文档中用自然语言描述活动，我会自动解析并生成配置。
要试试吗？"

【用户】好的

【Agent】
✅ 已从你的历史文档中提取了 12 个真实案例作为训练数据。
现在你可以试试写："配置春节红包雨活动，1月28日-2月5日，每人每天最多领3次"
```
</details>

---

##### 3.1.3.2 Skill 生成流程 (Auto-Generation Pipeline)

```
用户教学 (对话/示范/文档)
    ↓
Agent 理解意图 (Reasoning Model: o1/DeepSeek-R1)
    ↓
提取关键要素 (参数 Schema + 业务规则 + API 调用逻辑)
    ↓
生成 Skill 定义 (JSON Schema + Function Code)
    ↓
用户确认 & 测试 (沙盒环境试运行)
    ↓
部署到 Skill Library (立即可用)
```

**技术实现** (2026 年可行方案)：

| 阶段 | 技术方案 | 说明 |
|-----|---------|------|
| **意图理解** | Reasoning Models (o1/DeepSeek-R1) | 从对话或示范中提取用户真实意图 |
| **Schema 生成** | LLM-based Code Generation | 自动生成 JSON Schema 和参数验证规则 |
| **代码生成** | [OpenAI Code Interpreter (2024)](https://platform.openai.com/docs/assistants/tools/code-interpreter) / [Cursor Composer (2025)](https://www.cursor.com/) | 生成 Skill 的执行代码（Python/TypeScript） |
| **安全沙盒** | Docker Container / Firecracker | 在隔离环境中测试新 Skill |
| **版本管理** | Git-based Skill Versioning | 每个 Skill 自动创建 Git 仓库，支持回滚 |

**参考案例**：
*   [Cursor 的 Agent Skills 系统 (2024-2025)](https://docs.cursor.com/context/rules-for-ai) - 用户可以通过自然语言定义 Agent 行为规则
*   [Adept ACT-1 (2023)](https://www.adept.ai/blog/act-1) - 通过示范教 AI 操作软件
*   [Voyager (2023, NeurIPS)](https://arxiv.org/abs/2305.16291) - 通过自我提示生成新技能的 Minecraft Agent

---

##### 3.1.3.3 质量保障：从生成到可信 (Quality Assurance)

**自动生成的 Skill 如何确保可靠性？**

**✅ 三重防护机制**：

1.  **沙盒测试 (Sandbox Testing)**
    *   新 Skill 必须先在隔离环境中运行。
    *   Agent 自动生成测试用例（基于用户提供的示例）。
    *   用户可以看到测试结果，确认无误后才能正式启用。

2.  **人类审核 (Human-in-the-loop)**
    *   关键操作（如数据库写入、外部 API 调用）需要用户明确授权。
    *   Skill 的权限范围在生成时由用户定义（只读 / 可写 / 需确认）。

3.  **持续监控 (Continuous Monitoring)**
    *   每次 Skill 执行后，记录成功率、错误日志。
    *   如果某个 Skill 连续失败超过阈值，自动禁用并通知用户。

**💡 进化路径**：

```
初始版本 (v1.0)
  → 用户使用 10 次，发现 2 次参数解析错误
  → Agent 学习修正 (v1.1)
  → 用户继续使用，成功率提升到 95%
  → Agent 自动优化提示词和规则 (v1.2)
  → 最终稳定版本 (v2.0)，成为团队标准 Skill
```

---

##### 3.1.3.4 实际价值：打破技能瓶颈 (Breaking the Skill Bottleneck)

**传统方式**：
*   PD 提需求 → 等待开发者开发 Skill（1-2周）→ 上线使用。
*   **瓶颈**：开发者成为 Skill 创建的唯一入口。

**Workbench 方式**：
*   PD 在文档中描述/演示需求 → Agent 5分钟内生成 Skill → 立即测试使用。
*   **解放**：每个用户都能创建符合自己业务需求的 Skill。

**飞轮效应**：

$$
\text{用户创建新 Skill} \rightarrow \text{其他人复用} \rightarrow \text{Skill 库丰富} \rightarrow \text{Agent 更智能} \rightarrow \text{创建成本更低}
$$

*   **第 1 个月**：用户手动教 Agent 创建 5 个 Skill，每个需要 30 分钟。
*   **第 3 个月**：Skill 库已有 50 个，Agent 能自动复用类似模式，新 Skill 创建时间降至 5 分钟。
*   **第 6 个月**：Agent 已掌握团队的业务知识，80% 的需求能直接匹配现有 Skill 或自动生成。

**这不仅是工具的进化，更是组织能力的进化** 🚀

---

#### 3.1.4 实现基础 (Technical Foundation)

**这不是科幻，而是基于当前可行的技术栈** ✅

| 组件 | 技术方案 (2026) | 作用 |
|-----|----------------|------|
| **执行日志存储** | 结构化日志 + 向量数据库（如 Pinecone / Weaviate） | 存储每次 Skill 执行的<输入文本, 参数, 结果, 反馈> |
| **模式识别** | Few-shot Learning + RAG (检索增强生成) | 根据当前输入检索历史相似案例 |
| **规则提取** | Reasoning Models (如 DeepSeek-R1 / o1) | 从多次执行日志中推理出隐含的业务规则 |
| **Schema 进化** | LLM-based Schema Generation | 根据自然语言描述自动生成/修改 JSON Schema |
| **反馈闭环** | Human-in-the-loop | 关键决策（如扩展 Schema）需要人类确认 |

**参考案例**:
*   [OpenAI Function Calling Evolution (2023-2025)](https://platform.openai.com/docs/guides/function-calling) - 从静态工具到动态工具描述
*   [Microsoft Semantic Kernel Plugins (2024)](https://learn.microsoft.com/en-us/semantic-kernel/) - 插件化 Agent 能力
*   [LangChain Dynamic Tools (2025)](https://python.langchain.com/docs/modules/tools/) - 工具自动生成与优化

#### 3.1.5 价值飞轮 (The Flywheel Effect)

$$
\text{使用越多} \rightarrow \text{数据越多} \rightarrow \text{Skill 越智能} \rightarrow \text{体验越好} \rightarrow \text{使用更多}
$$

*   **第 1 天**: Skill 是初学者，需要用户详细描述每个参数。
*   **第 30 天**: Skill 已经记住了 50 个成功案例，能自动补全大部分字段。
*   **第 180 天**: Skill 成为领域专家，甚至能发现用户描述中的逻辑漏洞，主动提出优化建议。

**这就是 Workbench 的终极形态**：不仅是工具，而是一个**会成长的业务伙伴** 🚀

---

## 4. 典型工作流 (The "Alive" Workflow)

### 场景 A：从 Sticker 到 正式规格再到 执行 (MVP: 消费券配置)
> **The Hello World of Workbench**: 用一个极度具体、极度真实的案例，跑通整个流程。

1.  **Input (撰写)**: 
    *   PD 写下 PRD 片段：“配置一张新春开门红券，满100减10，且不能与新人券叠加。”
2.  **Process (意图识别)**: 
    *   `VoucherConfigSkill` 介入。Agent 识别到 "满100减10" (Threshold=100, Value=10) 和 "互斥规则" (Mutex=NewUserVoucher)。
    *   **Linter 介入**: 如果 PD 写了 "满50减100"，Linter 会立即报错 "优惠金额不能大于门槛"。
3.  **Output (执行)**: 
    *   生成 JSON Config。
    *   **Action Preview**: 用户预览并确认。
    *   **API Call**: 调用后台接口创建券，并返回测试二维码。

### 场景 B：会议纪要的自动化流转
1.  **记录**: 在 `Meeting-Notes-20260122.md` 中记录 " @Frontend 需优化首屏加载，@Backend 需扩容数据库"。
2.  **分发**: 
    *   `Jira Skill` 自动识别 `@Frontend`，在 Linear 创建工单并关联此文档链接。
    *   `DevOps Skill` 识别到数据库扩容需求，生成一个 Terraform 变更建议供运维 Review。

---

## 5. 竞品差异化

| 特性 | Notion AI | **Product Agent Workbench** |
| :--- | :--- | :--- |
| **定位** | **内容生成助手** (帮你写) | **业务执行代理** (帮你做) |
| **文档性质** | 用于阅读的文本 | **用于执行的指令 (Executable)** |
| **核心逻辑** | Human -> Text | **Human -> Knowledge -> Agent -> Reality** |
| **输出物** | 更多的文字 | **API 请求、SQL、JSON、Ticket** |
| **交互核心** | 聊天对话框 | **行内编辑 + Action Preview** |

---

## 6. 总结

**Workbench = Cursor for General Business Logic.**

它融合了：
1.  **Sticker 的灵动**：捕捉稍纵即逝的想法。
2.  **Editor 的深度**：将想法打磨成确定性的文档。
3.  **Agent Skills 的广度**：将文档转化为驱动企业的真实动作。

我们不再是在 "写文档"，我们是在 **"编写企业的业务逻辑"**。

---

## Appendix: The Master Algorithm

我们手中的不仅是两个产品（Writer IDE & Workbench），而是一套通用的 **Agentic Workflow 框架**。这个框架可以套用到任何知识密集型领域：

$$
\text{Value} = \text{Input (Editor)} \times \text{Process (Agent)} \times \text{Output (Skills)}
$$

### 1. Input (Editor) —— 知识定义层
*   **核心能力**: Cursor-like Editing (Context, Diff, Linter).
*   **目的**: 把模糊的 Sticker、脑图、口语，通过人机协作，变成**确定性的 Structured Docs**。
*   **对应产品**: `L0.2.1 - Writer's IDE` (Kernel)
*   *Without good input, Agent just amplifies noise.*

### 2. Process (Agent) —— 意图理解层
*   **核心能力**: Understanding & Reasoning (Reasoning Models like o1/DeepSeek-R1).
*   **目的**: 理解文档背后的业务意图，匹配合适的工具，规划执行路径。
*   *The "Brain" that connects thoughts to actions.*

### 3. Output (Skills) —— 价值执行层
*   **核心能力**: Execution (API, SQL, Ticket, Config).
*   **目的**: 改变现实世界。将文档里的决策投射到业务系统中。
*   **对应产品**: `L0.2.2 - Product Workbench` (Application)
*   *Knowledge is potential power; Execution is kinetic power.*
